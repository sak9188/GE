#pragma once
#include <map>
#include <mutex>

#include "GE.h"
#include "GE_PyObject.h"
#include "GE_Singleton.h"

class GE_Ticker
{
	typedef std::map<GE::Uint64, GE_PyFunction*>		RegTickMap;
public:
	virtual ~GE_Ticker(void);

public:
	GE::Uint64				RegTick(GE::Uint32 uTimeSec, PyObject* pyCallBack_BorrowRef, PyObject* pyParam_BorrowRef);	//注册一个Tick
	bool					UnregTick(GE::Int64 uID);																	//取消一个tick
	bool					TriggerTick(GE::Int64 uID);																	//强制触发一个Tick
	bool					TriggerTick(GE::Int64 uID, PyObject* pyTrigger_BorrowRef);									//强制触发一个Tick

	virtual bool			CallPerTime() = 0;																		    //每个周期一次，驱动tick

    GE_PyObject&			GetPyObj() { return obj; }

protected:
	// 所有的都通过下面的子类来驱动，这个类是不可以被构造的
	GE_Ticker(void);
	GE_Ticker(PyObject* pPyOwner_BorrowRef);

	void Init() {};

	RegTickMap rigsters;
	GE::Uint32	incId;
	GE_PyObject	obj;
};

// 秒级别的定时器
class GE_SlowTicker 
	: public GE_Ticker, public GE_Singleton<GE_SlowTicker>
{
public:
	GE_SlowTicker(void);
	~GE_SlowTicker(void);
};

// 分钟级别的定时器
class GE_IntervalTicker 
	: public GE_Ticker, public GE_Singleton<GE_IntervalTicker>
{
public:
	GE_IntervalTicker(void);
	~GE_IntervalTicker(void);
};

// 小时级别的定时器
class GE_HourTicker 
	: public GE_Ticker, public GE_Singleton<GE_HourTicker>
{
public:
	GE_HourTicker();
	~GE_HourTicker();
};

// 天级别的定时器
class GE_PeriodTicker 
	: public GE_Ticker, public GE_Singleton<GE_PeriodTicker>
{
public:
	GE_PeriodTicker(void);
	~GE_PeriodTicker(void);
};
